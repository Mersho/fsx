#!/usr/bin/env fsharpi

open System
open System.IO
open System.Linq

#load "Infra.fs"
open FSX.Infrastructure

let verbose = false

let PrintUsage () =
    Console.WriteLine("Usage: ./fsx.fsx  [OPTION]... yourscript.fsx")
    Console.WriteLine()
    Console.WriteLine("Options")
    Console.WriteLine("  -c, --compile     Only compile, don't run (ideal for CI build scripts)")
    Console.WriteLine("  -k, --check       Check if it compiles, without generating binaries")

let args = Util.FsxArguments()
if (args.Length = 0 || (args.Length = 1 && args.[0] = "--help")) then
    PrintUsage()
    Environment.Exit(1)

type Flag = OnlyCompile | OnlyCheck
type ProvidedCommandLineArguments =
    { Flags: list<Flag>; MaybeScript: Option<FileInfo> }
type ParsedCommandLineArguments =
    { Flags: list<Flag>; Script: FileInfo }

type BinFolder = { Dir: DirectoryInfo; Created: bool }
type ExeTarget = { Exe: FileInfo; BinFolderCreated: bool }
type BuildResult = Failure of BinFolder | Success of ExeTarget

let rec ParseArgsInternal (args: string list) (finalArgs: ProvidedCommandLineArguments): ProvidedCommandLineArguments =
    match args with
    | [] -> finalArgs
    | arg::tail ->
        let maybeFlag: Option<Flag> =
            if (arg = "-c" || arg = "--compile") then
                Some(OnlyCompile)
            else if (arg = "-k" || arg = "--check") then
                Some(OnlyCheck)
            else if (arg.StartsWith("-")) then
                failwith (sprintf "Flag not recognized: %s" arg)
            else
                None

        let newArgs =
            match maybeFlag with
            | None ->
                if not (arg.EndsWith(".fsx")) then
                    failwith (sprintf "Argument not recognized: %s. Only commands, or scripts ending with .fsx allowed" arg)
                else if (finalArgs.MaybeScript.IsSome) then
                    failwith (sprintf "Only one .fsx script allowed")
                else
                    { Flags = finalArgs.Flags; MaybeScript = Some(FileInfo(arg)) }
            | Some(flag) ->
                    { Flags = flag::finalArgs.Flags; MaybeScript = finalArgs.MaybeScript }

        ParseArgsInternal tail newArgs

exception NoScriptProvided

let ParseArgs(args: string list): ParsedCommandLineArguments =
    let parsedArgs = ParseArgsInternal args { Flags = []; MaybeScript = None }
    match parsedArgs.MaybeScript with
    | None -> raise (NoScriptProvided)
    | Some(scriptFileName) -> { Flags = parsedArgs.Flags; Script = scriptFileName }

let LOAD_PREPROCESSOR = "#load \""
let REF_PREPROCESSOR = "#r \""

type PreProcessorAction = Skip | Load of string | Ref of string
type LineAction = Normal | PreProcessorAction of PreProcessorAction
type CompilerInput = SourceFile of FileInfo | Ref of string

let GetBinFolderForAScript(script: FileInfo) =
    DirectoryInfo(Path.Combine(script.Directory.FullName, "bin"))

let GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder (orig: FileInfo) (extension: string) =
    let binDir = GetBinFolderForAScript(orig)
    let autogeneratedFileName = sprintf "%s.%s" (Path.GetFileNameWithoutExtension(orig.FullName)) extension
    let autogeneratedFile = FileInfo(Path.Combine(binDir.FullName, autogeneratedFileName))
    autogeneratedFile,binDir

let BuildFsxScript(script: FileInfo): BuildResult =
    if (script = null) then
        raise(ArgumentNullException("script"))
    if not (script.FullName.EndsWith(".fsx")) then
        invalidArg "script" "The script filename needs to end with .fsx extension"

    let binFolderExistedOriginally = GetBinFolderForAScript(script).Exists

    let readPreprocessorLine(line: string) =
        if (line.StartsWith("#!")) then
            PreProcessorAction.Skip
        else if (line.StartsWith(LOAD_PREPROCESSOR)) then
            let fileToLoad = line.Substring(LOAD_PREPROCESSOR.Length, line.Length - LOAD_PREPROCESSOR.Length - 1)
            PreProcessorAction.Load(fileToLoad)
        else if (line.StartsWith(REF_PREPROCESSOR)) then
            let libToRef = line.Substring(REF_PREPROCESSOR.Length, line.Length - REF_PREPROCESSOR.Length - 1)
            PreProcessorAction.Ref(libToRef)
        else
            failwith (sprintf "Unrecognized preprocessor line: %s" line)

    let readLine (line: string) (origScript: FileInfo): LineAction =
        if (line.StartsWith("#")) then
            LineAction.PreProcessorAction(readPreprocessorLine(line))
        else
            LineAction.Normal

    let rec preprocessScriptContents(origScript: FileInfo): List<CompilerInput> =
        let autogeneratedFile,binFolder = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder origScript "fs"
        if not (binFolder.Exists) then
            Directory.CreateDirectory(binFolder.FullName) |> ignore
        File.Copy(origScript.FullName, autogeneratedFile.FullName, true)
        let contents = File.ReadAllText(autogeneratedFile.FullName)
        let lines = contents.Split([| Environment.NewLine |], StringSplitOptions.None)

        File.WriteAllText(autogeneratedFile.FullName, String.Empty)

        seq {
            for line in lines do

                let startCommentInFSharp = "//"

                let maybeDep = readLine line origScript
                match maybeDep with
                | LineAction.Normal ->
                    File.AppendAllText(autogeneratedFile.FullName, line + Environment.NewLine)
                | LineAction.PreProcessorAction(action) ->
                    File.AppendAllText(autogeneratedFile.FullName, startCommentInFSharp + line + Environment.NewLine)
                    match action with
                    | PreProcessorAction.Skip -> ()
                    | PreProcessorAction.Load(fileName) ->
                        let file = FileInfo(Path.Combine(origScript.Directory.FullName, fileName))
                        yield CompilerInput.SourceFile(file)
                    | PreProcessorAction.Ref(refName) ->
                        yield CompilerInput.Ref(refName)
            yield CompilerInput.SourceFile(autogeneratedFile)
        } |> List.ofSeq

    let getFiles(flags: seq<CompilerInput>): seq<FileInfo>=
        seq {
            for f in flags do
                match f with
                | CompilerInput.SourceFile(file) -> yield file
                | _ -> ()
        }

    let getCompilerReferences(flags: seq<CompilerInput>): seq<string>=
        seq {
            for f in flags do
                match f with
                | CompilerInput.Ref(refName) -> yield sprintf "--reference:%s" refName
                | _ -> ()
        }

    if (verbose) then
        Console.WriteLine("Building {0}", script)

    let binFolder = GetBinFolderForAScript(script)
    let compilerInputParams = preprocessScriptContents(script)
    let filesToCompile = getFiles(compilerInputParams)
    let exitCode,exeTarget =
        try
            let exeTarget,_ = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder script "exe"
            let sourceFiles = String.Join(" ", filesToCompile)
            let refs = String.Join (" ", getCompilerReferences(compilerInputParams))
            let fscompilerflags = (sprintf "%s --target:exe --out:%s %s" refs exeTarget.FullName sourceFiles)
            let processResult = Process.Execute("fsharpc " + fscompilerflags, verbose, (not verbose))
            if not (processResult.ExitCode = 0) then
                Process.PrintToScreen(processResult.Output)
            processResult.ExitCode,exeTarget

        finally
            let autogeneratedFiles = filesToCompile.Where(fun f -> f.Directory.FullName.Equals(binFolder.FullName))
            for file in autogeneratedFiles do
                file.Delete()

    let success =
        match exitCode with
        | 0 -> true
        | _ -> false

    if not (success) then
        Console.Error.WriteLine("Build failure")
        BuildResult.Failure({ Dir = binFolder; Created = (not binFolderExistedOriginally) })
    else
        BuildResult.Success({ Exe = exeTarget; BinFolderCreated = (not binFolderExistedOriginally) })

let parsedArgs =
    try
        ParseArgs(args)
    with
    | :? NoScriptProvided ->
        Console.Error.WriteLine("At least one .fsx script is required as input. Use --help for info.")
        Environment.Exit(1)
        failwith "Unreachable"

// FIXME: check dependencies of file too
let GetAlreadyBuiltExecutable(script: FileInfo): Option<FileInfo> =
    let exeTarget,binFolder = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder script "exe"
    if not (binFolder.Exists) then
        None
    else if (binFolder.LastWriteTime < script.LastWriteTime) then
        None
    else if not (exeTarget.Exists) then
        None
    else if (exeTarget.LastWriteTime < script.LastWriteTime) then
        None
    else
        Some(exeTarget)

let RunTheExecutable(exe: FileInfo) =
    let runResult = Process.Execute(sprintf "mono %s" exe.FullName, false, false)
    runResult.ExitCode

let Build() =
    let buildResult = BuildFsxScript(parsedArgs.Script)

    match buildResult with
    | Failure(binFolder) ->
        if (binFolder.Created) then
            binFolder.Dir.Delete(true)
        Environment.Exit(1)

    | Success(exeTarget) ->
        if (parsedArgs.Flags.Contains(Flag.OnlyCheck)) then
            if (exeTarget.BinFolderCreated) then
                exeTarget.Exe.Directory.Delete(true)
            Environment.Exit(0)

        if (parsedArgs.Flags.Contains(Flag.OnlyCompile)) then
            Environment.Exit(0)
        else
            let exitCodeOfTheRun = RunTheExecutable(exeTarget.Exe)
            Environment.Exit(exitCodeOfTheRun)

// if it has any of these 2 flags, force build, not even check if the .exe is there
if (parsedArgs.Flags.Contains(Flag.OnlyCheck) ||
    parsedArgs.Flags.Contains(Flag.OnlyCompile)) then
    Build()

else
    let maybeExe = GetAlreadyBuiltExecutable(parsedArgs.Script)
    match maybeExe with
    | Some(exe) ->
        let exitCodeOfTheRun = RunTheExecutable(exe)
        Environment.Exit(exitCodeOfTheRun)
    | None ->
        Build()
