#!/usr/bin/env fsharpi

open System
open System.IO
open System.Linq

#load "Infra.fs"
open FSX.Infrastructure

let verbose = false

let PrintUsage () =
    Console.WriteLine("Usage: ./fsx.fsx  [OPTION]... yourscript.fsx")
    Console.WriteLine()
    Console.WriteLine("Options")
    Console.WriteLine("  -c, --compile     Only compile, don't run (ideal for CI build scripts)")

let args = Util.FsxArguments()
if (args.Length = 0 || (args.Length = 1 && args.[0] = "--help")) then
    PrintUsage()
    Environment.Exit(1)

let rec FindScript(args: string list, script: Option<FileInfo>): Option<FileInfo> =
    match args with
    | [] -> script
    | arg::tail ->
        let isScript = arg.EndsWith(".fsx")
        let isCommand = (arg = "-c" || arg = "--compile")

        if ((not isScript) && (not isCommand)) then
            failwith (sprintf "Argument not recognized: %s. Only commands or scripts ending with .fsx allowed" arg)

        match script with
        | None ->
            if (isScript) then
                FindScript(tail, Some(new FileInfo(arg)))
            else
                FindScript(tail, None)
        | Some(alreadyScript) ->
            if (isScript) then
                failwith (sprintf "Only one .fsx script allowed")
            FindScript(tail, script)

let LOAD_PREPROCESSOR = "#load \""

type PreProcessorAction = Skip | Load of string
type LineAction = Normal | PreProcessorSkip | PreProcessorDependencies of seq<FileInfo>

let BuildFsxScript(script: FileInfo) : bool =
    if (script = null) then
        raise(new ArgumentNullException("script"))
    if not (script.FullName.EndsWith(".fsx")) then
        invalidArg "script" "The script filename needs to end with .fsx extension"

    let dealWithPreprocessorLine(line: string) =
        if (line.StartsWith("#!")) then
            PreProcessorAction.Skip
        else if (line.StartsWith(LOAD_PREPROCESSOR)) then
            let fileToLoad = line.Substring(LOAD_PREPROCESSOR.Length, line.Length - LOAD_PREPROCESSOR.Length - 1)
            PreProcessorAction.Load(fileToLoad)
        else
            failwith (sprintf "Unrecognized preprocessor line: %s" line)

    let dealWithLine(line: string, origScript: FileInfo, func): LineAction =
        if (line.StartsWith("#")) then
            let prepResult = dealWithPreprocessorLine(line)
            match prepResult with
            | Skip -> LineAction.PreProcessorSkip
            | PreProcessorAction.Load(prepFile) ->
                let origLibFile = FileInfo(Path.Combine(origScript.Directory.FullName, prepFile))
                PreProcessorDependencies(func(origLibFile))
        else
            LineAction.Normal

    let GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder(orig: FileInfo, extension: string) =
        let binDir = DirectoryInfo(Path.Combine(script.Directory.FullName, "bin"))
        if not (binDir.Exists) then
            Directory.CreateDirectory(binDir.FullName) |> ignore
        FileInfo(Path.Combine(binDir.FullName, Path.GetFileNameWithoutExtension(orig.FullName) + "." + extension))

    let rec preprocessScriptContents(origScript: FileInfo): seq<FileInfo> =
        let autogeneratedFile = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder(origScript, "fs")
        File.Copy(origScript.FullName, autogeneratedFile.FullName, true)
        let contents = File.ReadAllText(autogeneratedFile.FullName)
        let lines = contents.Split([| Environment.NewLine |], StringSplitOptions.None)

        File.WriteAllText(autogeneratedFile.FullName, String.Empty)

        seq {
            for line in lines do
                let maybeDep = dealWithLine(line, origScript, preprocessScriptContents)
                match maybeDep with
                | Normal -> File.AppendAllText(autogeneratedFile.FullName, line + Environment.NewLine)
                | PreProcessorSkip -> ()
                | PreProcessorDependencies(deps) ->
                    for dep in deps do
                        yield dep
            yield autogeneratedFile
        }

    if (verbose) then
        Console.WriteLine("Building {0}", script)

    let autogenFiles = preprocessScriptContents(script)
    let exitCode =
        try
            let exeTarget = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder(script, "exe")
            let fscompilerflags = (sprintf "--target:exe --out:%s %s" exeTarget.FullName (String.Join(" ", autogenFiles)))
            let exitCode,_,_ = Process.Execute("fsharpc " + fscompilerflags, verbose, (not verbose))
            exitCode

        finally
            for autogenFile in autogenFiles do
                autogenFile.Delete()

    let success =
        match exitCode with
        | 0 -> true
        | _ -> false

    if not (success) then
        Console.Error.WriteLine("Build failure")

    success

let maybeScript = FindScript(args, None)
match maybeScript with
| None ->
    Console.Error.WriteLine("At least one .fsx script is required as input. Use --help for info.")
    Environment.Exit(1)
| Some(script) ->
    if (BuildFsxScript(script)) then
        Environment.Exit(0)
    else
        Environment.Exit(1)