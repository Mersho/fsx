#!/usr/bin/env fsharpi

open System
open System.IO
open System.Linq

#load "Infra.fs"
open FSX.Infrastructure

let verbose = false

let PrintUsage () =
    Console.WriteLine("Usage: ./fsx.fsx  [OPTION]... yourscript.fsx")
    Console.WriteLine()
    Console.WriteLine("Options")
    Console.WriteLine("  -c, --compile     Only compile, don't run (ideal for CI build scripts)")
    Console.WriteLine("  -k, --check       Check if it compiles, without generating binaries")

let args = Util.FsxArguments()
if (args.Length = 0 || (args.Length = 1 && args.[0] = "--help")) then
    PrintUsage()
    Environment.Exit(1)

type Flag = OnlyCompile | OnlyCheck
type CommandLineArguments =
    { Flags: list<Flag>; MaybeScript: Option<FileInfo> }
type FinalCommandLineArguments =
    { Flags: list<Flag>; Script: FileInfo }

type BinFolder = { Dir: DirectoryInfo; Created: bool }
type ExeTarget = { Exe: FileInfo; BinFolderCreated: bool }
type BuildResult = Failure of BinFolder | Success of ExeTarget

let rec ParseArgsInternal(args: string list, finalArgs: CommandLineArguments): CommandLineArguments =
    match args with
    | [] -> finalArgs
    | arg::tail ->
        let maybeFlag: Option<Flag> =
            if (arg = "-c" || arg = "--compile") then
                Some(OnlyCompile)
            else if (arg = "-k" || arg = "--check") then
                Some(OnlyCheck)
            else if (arg.StartsWith("-")) then
                failwith (sprintf "Flag not recognized: %s" arg)
            else
                None

        match maybeFlag with
        | None ->
            if not (arg.EndsWith(".fsx")) then
                failwith (sprintf "Argument not recognized: %s. Only commands, or scripts ending with .fsx allowed" arg)
            else if (finalArgs.MaybeScript.IsSome) then
                failwith (sprintf "Only one .fsx script allowed")
            else
                let newArgs = { Flags = finalArgs.Flags; MaybeScript = Some(FileInfo(arg)) }
                ParseArgsInternal(tail, newArgs)
        | Some(flag) ->
            let newArgs = { Flags = flag::finalArgs.Flags; MaybeScript = finalArgs.MaybeScript }
            ParseArgsInternal(tail, newArgs)

exception NoScriptProvided

let ParseArgs(args: string list): FinalCommandLineArguments =
    let parsedArgs = ParseArgsInternal(args, { Flags = []; MaybeScript = None })
    match parsedArgs.MaybeScript with
    | None -> raise (NoScriptProvided)
    | Some(scriptFileName) -> { Flags = parsedArgs.Flags; Script = scriptFileName }

let LOAD_PREPROCESSOR = "#load \""

type PreProcessorAction = Skip | Load of string
type LineAction = Normal | PreProcessorSkip | PreProcessorDependencies of seq<FileInfo>

let GetBinFolderForAScript(script: FileInfo) =
    DirectoryInfo(Path.Combine(script.Directory.FullName, "bin"))

let GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder(orig: FileInfo, extension: string) =
    let binDir = GetBinFolderForAScript(orig)
    let autogenFile = FileInfo(Path.Combine(binDir.FullName, Path.GetFileNameWithoutExtension(orig.FullName) + "." + extension))
    autogenFile,binDir

let BuildFsxScript(script: FileInfo) : BuildResult =
    if (script = null) then
        raise(new ArgumentNullException("script"))
    if not (script.FullName.EndsWith(".fsx")) then
        invalidArg "script" "The script filename needs to end with .fsx extension"

    let binFolderExistedOriginally = GetBinFolderForAScript(script).Exists

    let dealWithPreprocessorLine(line: string) =
        if (line.StartsWith("#!")) then
            PreProcessorAction.Skip
        else if (line.StartsWith(LOAD_PREPROCESSOR)) then
            let fileToLoad = line.Substring(LOAD_PREPROCESSOR.Length, line.Length - LOAD_PREPROCESSOR.Length - 1)
            PreProcessorAction.Load(fileToLoad)
        else
            failwith (sprintf "Unrecognized preprocessor line: %s" line)

    let dealWithLine(line: string, origScript: FileInfo, func): LineAction =
        if (line.StartsWith("#")) then
            let prepResult = dealWithPreprocessorLine(line)
            match prepResult with
            | Skip -> LineAction.PreProcessorSkip
            | PreProcessorAction.Load(prepFile) ->
                let origLibFile = FileInfo(Path.Combine(origScript.Directory.FullName, prepFile))
                PreProcessorDependencies(func(origLibFile))
        else
            LineAction.Normal

    let rec preprocessScriptContents(origScript: FileInfo): seq<FileInfo> =
        let autogeneratedFile,binFolder = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder(origScript, "fs")
        if not (binFolder.Exists) then
            Directory.CreateDirectory(binFolder.FullName) |> ignore
        File.Copy(origScript.FullName, autogeneratedFile.FullName, true)
        let contents = File.ReadAllText(autogeneratedFile.FullName)
        let lines = contents.Split([| Environment.NewLine |], StringSplitOptions.None)

        File.WriteAllText(autogeneratedFile.FullName, String.Empty)

        seq {
            for line in lines do

                let startCommentInFSharp = "//"

                let maybeDep = dealWithLine(line, origScript, preprocessScriptContents)
                match maybeDep with
                | Normal ->
                    File.AppendAllText(autogeneratedFile.FullName, line + Environment.NewLine)
                | PreProcessorSkip ->
                    File.AppendAllText(autogeneratedFile.FullName, startCommentInFSharp + line + Environment.NewLine)
                | PreProcessorDependencies(deps) ->
                    File.AppendAllText(autogeneratedFile.FullName, startCommentInFSharp + line + Environment.NewLine)
                    for dep in deps do
                        yield dep
            yield autogeneratedFile
        }

    if (verbose) then
        Console.WriteLine("Building {0}", script)

    let autogenFiles = preprocessScriptContents(script)
    let exitCode,binFolder,exeTarget =
        try
            let exeTarget,binFolder = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder(script, "exe")
            if not (binFolder.Exists) then
                Directory.CreateDirectory(binFolder.FullName) |> ignore
            let fscompilerflags = (sprintf "--target:exe --out:%s %s" exeTarget.FullName (String.Join(" ", autogenFiles)))
            let processResult = Process.Execute("fsharpc " + fscompilerflags, verbose, (not verbose))
            if not (processResult.ExitCode = 0) then
                Process.PrintToScreen(processResult.Output)
            processResult.ExitCode,binFolder,exeTarget

        finally
            for autogenFile in autogenFiles do
                autogenFile.Delete()

    let success =
        match exitCode with
        | 0 -> true
        | _ -> false

    if not (success) then
        Console.Error.WriteLine("Build failure")
        BuildResult.Failure({ Dir = binFolder; Created = (not binFolderExistedOriginally) })
    else
        BuildResult.Success({ Exe = exeTarget; BinFolderCreated = (not binFolderExistedOriginally) })

let parsedArgs =
    try
        ParseArgs(args)
    with
    | :? NoScriptProvided ->
        Console.Error.WriteLine("At least one .fsx script is required as input. Use --help for info.")
        Environment.Exit(1)
        failwith "Unreachable"

// FIXME: check dependencies of file too
let GetAlreadyBuiltExecutable(script: FileInfo): Option<FileInfo> =
    let exeTarget,binFolder = GetEquivalentFileForAutogeneratedCounterPartInBinSubfolder(script, "exe")
    if not (binFolder.Exists) then
        None
    else if (binFolder.LastWriteTime < script.LastWriteTime) then
        None
    else if not (exeTarget.Exists) then
        None
    else if (exeTarget.LastWriteTime < script.LastWriteTime) then
        None
    else
        Some(exeTarget)

let RunTheExecutable(exe: FileInfo) =
    let runResult = Process.Execute(sprintf "mono %s" exe.FullName, false, false)
    runResult.ExitCode

let maybeExe = GetAlreadyBuiltExecutable(parsedArgs.Script)
match maybeExe with
| Some(exe) ->
    if (parsedArgs.Flags.Contains(Flag.OnlyCheck)) then
        Environment.Exit(0)
    if (parsedArgs.Flags.Contains(Flag.OnlyCompile)) then
        Environment.Exit(0)

    let exitCodeOfTheRun = RunTheExecutable(exe)
    Environment.Exit(exitCodeOfTheRun)

| None ->
    let buildResult = BuildFsxScript(parsedArgs.Script)

    match buildResult with
    | Failure(binFolder) ->
        if (binFolder.Created) then
            binFolder.Dir.Delete(true)
        Environment.Exit(1)

    | Success(exeTarget) ->
        if (parsedArgs.Flags.Contains(Flag.OnlyCheck)) then
            if (exeTarget.BinFolderCreated) then
                exeTarget.Exe.Directory.Delete(true)
                Environment.Exit(0)

        if (parsedArgs.Flags.Contains(Flag.OnlyCompile)) then
            Environment.Exit(0)
        else
            let exitCodeOfTheRun = RunTheExecutable(exeTarget.Exe)
            Environment.Exit(exitCodeOfTheRun)
